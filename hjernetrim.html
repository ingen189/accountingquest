<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß† Hjernetrim - AccountingQuest</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß†</text></svg>">
    <meta name="theme-color" content="#0f1419">

        
    <!-- External CSS -->
    <link rel="stylesheet" href="css/main.css">
    
    <style>
        /* ===== PAGE SPECIFIC STYLES ===== */

        * { margin: 0; padding: 0; box-sizing: border-box; }

        

        

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            transition: background 0.3s;
        }

        /* Header */
        .game-header {
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header-left { display: flex; align-items: center; gap: 20px; flex-wrap: wrap; }

        .back-btn, .theme-toggle, .wiki-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .back-btn:hover, .theme-toggle:hover {
            background: var(--accent);
            color: var(--bg-primary);
        }

        .wiki-btn {
            background: var(--warning);
            color: white;
        }

        .wiki-btn:hover {
            background: var(--warning);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 158, 11, 0.4);
        }

        .stat-item {
            background: var(--bg-tertiary);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.95em;
        }

        .stat-value { color: var(--accent); font-weight: bold; }

        /* Lock Screen */
        .lock-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .lock-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
            background: var(--bg-secondary);
            border: 3px solid var(--warning);
            border-radius: 20px;
        }

        .lock-icon { font-size: 5em; margin-bottom: 20px; }
        .lock-title { font-size: 2em; color: var(--accent); margin-bottom: 20px; }

        .requirements-box {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: left;
        }

        .requirement-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: var(--bg-primary);
            border-radius: 5px;
        }

        .requirement-met { color: var(--accent); }
        .requirement-not-met { color: var(--error); }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--bg-tertiary);
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent-hover));
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            transition: width 0.5s;
        }

        /* Main Content */
        .game-content { display: flex; min-height: calc(100vh - 100px); }

        .sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-right: 2px solid var(--border-color);
            overflow-y: auto;
            padding: 20px;
        }

        .sidebar h3 {
            color: var(--accent);
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        .difficulty-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .difficulty-master { background: rgba(239, 68, 68, 0.2); color: var(--error); }
        .difficulty-expert { background: rgba(245, 158, 11, 0.2); color: var(--warning); }

        .task-item {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 3px solid transparent;
            margin-bottom: 12px;
        }

        .task-item:hover {
            background: var(--bg-secondary);
            border-left-color: var(--accent);
            transform: translateX(5px);
        }

        .task-item.active { background: rgba(74, 222, 128, 0.2); border-left-color: var(--accent); }
        .task-item.completed { border-left-color: var(--accent-hover); opacity: 0.7; }

        .task-item-title { font-weight: bold; color: var(--text-primary); margin-bottom: 5px; }
        .task-item-desc { font-size: 0.85em; color: var(--text-secondary); line-height: 1.4; }

        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 0.75em;
            margin-top: 8px;
        }

        .status-badge.completed { background: rgba(34, 197, 94, 0.2); color: var(--accent-hover); }
        .status-badge.not-started { background: rgba(107, 114, 128, 0.2); color: var(--text-secondary); }

        /* Workspace */
        .workspace { flex: 1; padding: 30px; overflow-y: auto; }

        .task-header {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
        }

        .task-title {
            font-size: 1.8em;
            color: var(--accent);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .task-description {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 8px;
            line-height: 1.8;
            border-left: 4px solid var(--accent);
        }

        .task-description h4 {
            color: var(--accent);
            margin-bottom: 10px;
        }

        .task-description ul {
            margin: 10px 0 10px 25px;
        }

        .task-description li {
            margin: 5px 0;
        }

        /* ExcelGrid Styles */
        .excel-grid-wrapper {
            overflow-x: auto;
            border-radius: 10px;
            background: var(--bg-primary);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            margin: 20px 0;
        }

        .excel-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .excel-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 12px;
            border: 1px solid var(--bg-tertiary);
            text-align: center;
            font-weight: 600;
        }

        .excel-table td {
            border: 1px solid var(--bg-tertiary);
            padding: 0;
        }

        .cell-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .excel-cell {
            width: 100%;
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 12px;
            font-size: 0.95em;
            font-family: 'Consolas', 'Monaco', monospace;
            text-align: right;
            outline: none;
            transition: background 0.2s;
        }

        .excel-cell:focus {
            outline: 2px solid var(--accent);
            background: rgba(255,255,255,0.05);
            z-index: 5;
        }

        .excel-cell:hover {
            background: rgba(255,255,255,0.03);
        }

        .excel-cell.readonly {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: not-allowed;
        }

        .excel-cell.text-left {
            text-align: left;
        }

        /* Fill Handle */
        .fill-handle {
            position: absolute;
            right: 1px;
            bottom: 1px;
            width: 10px;
            height: 10px;
            background: var(--accent);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            cursor: crosshair;
            z-index: 25;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4), 0 0 0 1px rgba(74, 222, 128, 0.3);
            transition: all 0.2s ease;
        }

        .fill-handle:hover {
            width: 14px;
            height: 14px;
            right: -1px;
            bottom: -1px;
            background: #5ef77c;
            box-shadow: 0 3px 8px rgba(74, 222, 128, 0.8), 0 0 0 2px rgba(74, 222, 128, 0.5);
        }

        .excel-cell.filling {
            background: rgba(74, 222, 128, 0.25) !important;
        }

        .excel-cell.selecting-mode {
            cursor: crosshair;
            background: rgba(59, 130, 246, 0.1);
        }

        .excel-cell.selected-for-formula {
            outline: 3px solid var(--info) !important;
            background: rgba(59, 130, 246, 0.2) !important;
            animation: cellPulse 0.5s;
        }

        @keyframes cellPulse {
            0%, 100% { box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.8); }
        }

        .cell-selection-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-secondary);
            border: 2px solid var(--accent);
            border-radius: 12px;
            padding: 25px;
            z-index: 1000;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            color: var(--text-primary);
        }

        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 15px;
            margin: 25px 0;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1em;
        }

        .action-btn.hint {
            background: var(--warning);
            color: white;
        }

        .action-btn.hint:hover {
            background: var(--warning);
            transform: translateY(-2px);
        }

        .action-btn.reset {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .action-btn.reset:hover {
            background: #4a4a4a;
            transform: translateY(-2px);
        }

        .action-btn.check {
            background: var(--accent);
            color: white;
        }

        .action-btn.check:hover {
            background: var(--accent-hover);
            transform: translateY(-2px);
        }

        /* Hint Box */
        .hint-box {
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--info);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            display: none;
        }

        .hint-box.show { display: block; }

        .hint-title {
            color: var(--info);
            font-weight: bold;
            font-size: 1.2em;
            margin-bottom: 10px;
        }

        /* Feedback */
        .feedback {
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            font-weight: bold;
            text-align: center;
            display: none;
        }

        .feedback.show { display: block; }

        .feedback.correct {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid var(--accent);
            color: var(--accent);
        }

        .feedback.incorrect {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid var(--error);
            color: var(--error);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 300px;
                border-right: none;
                border-bottom: 2px solid var(--border-color);
            }

            .workspace {
                padding: 20px;
            }

            .task-title {
                font-size: 1.4em;
            }

            .calculator-popup {
                right: 10px;
                top: 80px;
            }
        }

        /* Calculator */
        .calculator-popup {
            position: fixed;
            right: 30px;
            top: 120px;
            background: var(--bg-secondary);
            border: 2px solid var(--accent);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            z-index: 1000;
            display: none;
        }

        .calculator-popup.show {
            display: block;
        }

        .calc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .calc-title {
            color: var(--accent);
            font-weight: bold;
            font-size: 1.2em;
        }

        .calc-close {
            background: var(--error);
            color: white;
            border: none;
            padding: 5px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }

        .calc-display {
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            font-size: 1.8em;
            font-family: 'Consolas', monospace;
            text-align: right;
            margin-bottom: 15px;
            color: var(--accent);
            min-height: 50px;
            overflow-x: auto;
        }

        .calc-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .calc-btn {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: none;
            padding: 15px;
            border-radius: 8px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .calc-btn:hover {
            background: #4a4a4a;
        }

        .calc-btn.operator {
            background: var(--info);
            color: white;
        }

        .calc-btn.operator:hover {
            background: #2563eb;
        }

        .calc-btn.equals {
            background: var(--accent);
            color: var(--bg-primary);
            grid-column: span 2;
        }

        .calc-btn.equals:hover {
            background: var(--accent-hover);
        }

        .calc-btn.clear {
            background: var(--error);
            color: white;
        }

        .calc-btn.clear:hover {
            background: #dc2626;
        }
    
    </style>

</head>
<body>
    <!-- Lock Screen -->
    <div class="lock-screen" id="lock-screen">
        <div class="lock-content">
            <div class="lock-icon">üîí</div>
            <h1 class="lock-title">üß† Hjernetrim</h1>
            <p style="font-size: 1.2em; margin-bottom: 20px;">
                Dette er ekstra vanskelige oppgaver for de mest dedikerte studentene!
            </p>
            
            <div class="requirements-box">
                <h3 style="color: var(--accent); margin-bottom: 15px;">üìã Krav for √• l√•se opp:</h3>
                <div class="requirement-item">
                    <span>Fullf√∏rt Quiz</span>
                    <span class="requirement-not-met" id="req-quiz">0%</span>
                </div>
                <div class="requirement-item">
                    <span>Fullf√∏rt Bokf√∏ring</span>
                    <span class="requirement-not-met" id="req-bokforing">0%</span>
                </div>
                <div class="requirement-item">
                    <span>Fullf√∏rt Regnskapsanalyse</span>
                    <span class="requirement-not-met" id="req-analyse">0%</span>
                </div>
                <div class="requirement-item">
                    <span>Fullf√∏rt Case Studies</span>
                    <span class="requirement-not-met" id="req-case">0%</span>
                </div>
            </div>

            <div class="progress-bar">
                <div class="progress-fill" id="overall-progress" style="width: 0%;">0%</div>
            </div>

            <p style="margin-top: 20px; color: var(--text-secondary);">
                Fullf√∏r de andre modulene for √• l√•se opp Hjernetrim!
            </p>

            <button class="back-btn" onclick="backToMenu()" style="margin-top: 20px;">‚Üê Tilbake til meny</button>
            
            <!-- Hidden unlock button for testing -->
            <button onclick="forceUnlock()" style="position: absolute; bottom: 10px; right: 10px; opacity: 0.1; background: none; border: none; cursor: pointer;">üîì</button>
        </div>
    </div>

    <!-- Main Game -->
    <div class="game-header">
        <div class="header-left">
            <button class="back-btn" onclick="backToMenu()">‚Üê Tilbake</button>
            <button class="wiki-btn" onclick="openWiki()">üìö Wiki</button>
            <div class="stat-item">
                <span style="color: var(--text-secondary);">Modul:</span>
                <span class="stat-value">üß† Hjernetrim</span>
            </div>
            <div class="stat-item" id="pro-badge" style="display: none; background: linear-gradient(135deg, #8b5cf6, #ec4899); color: white;">
                ‚≠ê PRO
            </div>
        </div>
        
        <div style="display: flex; gap: 15px; flex-wrap: wrap; align-items: center;">
            <div class="stat-item">
                <span style="color: var(--text-secondary);">Fullf√∏rt:</span>
                <span class="stat-value"><span id="completed-count">0</span>/10</span>
            </div>
            <div class="stat-item">
                <span style="color: var(--text-secondary);">Poeng:</span>
                <span class="stat-value" id="score">0</span>
            </div>
            <button class="theme-toggle" onclick="toggleTheme()">üåì Tema</button>
        </div>
    </div>

    <!-- Main Content -->
    <div class="game-content">
        <!-- Sidebar -->
        <div class="sidebar">
            <h3>üß† Ekstra vanskelige oppgaver</h3>
            <div id="task-list"></div>
        </div>

        <!-- Workspace -->
        <div class="workspace">
            <!-- Task Header -->
            <div class="task-header">
                <div class="task-title" id="task-title"></div>
                <div class="task-description" id="task-description"></div>
            </div>

            <!-- Excel Grid Container -->
            <div id="excel-grid-container"></div>

            <!-- Action Buttons -->
            <div class="action-buttons">
                <button class="action-btn" onclick="toggleCalculator()" style="background: var(--info); color: white;">üî¢ Kalkulator</button>
                <button class="action-btn hint" onclick="showHint()">üí° Hint</button>
                <button class="action-btn reset" onclick="resetTask()">üîÑ Reset</button>
                <button class="action-btn check" onclick="checkAnswer()">‚úì Sjekk svar</button>
            </div>

            <!-- Hint Box -->
            <div class="hint-box" id="hint-box">
                <div class="hint-title">üí° Hint:</div>
                <div id="hint-content"></div>
            </div>

            <!-- Feedback -->
            <div class="feedback" id="feedback"></div>
        </div>
    </div>

    <!-- Calculator -->
    <div class="calculator-popup" id="calculator">
        <div class="calc-header">
            <div class="calc-title">üî¢ Kalkulator</div>
            <button class="calc-close" onclick="toggleCalculator()">‚úï</button>
        </div>
        <div class="calc-display" id="calc-display">0</div>
        <div class="calc-buttons">
            <button class="calc-btn clear" onclick="calcClear()">C</button>
            <button class="calc-btn operator" onclick="calcInput('/')">/</button>
            <button class="calc-btn operator" onclick="calcInput('*')">√ó</button>
            <button class="calc-btn operator" onclick="calcInput('-')">-</button>
            
            <button class="calc-btn" onclick="calcInput('7')">7</button>
            <button class="calc-btn" onclick="calcInput('8')">8</button>
            <button class="calc-btn" onclick="calcInput('9')">9</button>
            <button class="calc-btn operator" onclick="calcInput('+')">+</button>
            
            <button class="calc-btn" onclick="calcInput('4')">4</button>
            <button class="calc-btn" onclick="calcInput('5')">5</button>
            <button class="calc-btn" onclick="calcInput('6')">6</button>
            <button class="calc-btn operator" onclick="calcInput('(')">(</button>
            
            <button class="calc-btn" onclick="calcInput('1')">1</button>
            <button class="calc-btn" onclick="calcInput('2')">2</button>
            <button class="calc-btn" onclick="calcInput('3')">3</button>
            <button class="calc-btn operator" onclick="calcInput(')')">)</button>
            
            <button class="calc-btn" onclick="calcInput('0')">0</button>
            <button class="calc-btn" onclick="calcInput('.')">.</button>
            <button class="calc-btn equals" onclick="calcEquals()">=</button>
        </div>
    </div>

    <!-- ExcelGrid Component -->
    <script>
        /**
         * ExcelGrid - Reusable Excel-like spreadsheet component
         */
        class ExcelGrid {
            constructor(containerId, options = {}) {
                this.container = document.getElementById(containerId);
                this.options = {
                    headers: options.headers || [],
                    allowFormulas: options.allowFormulas !== false,
                    allowCellSelection: options.allowCellSelection !== false,
                    allowFillHandle: options.allowFillHandle !== false,
                    showRowNumbers: options.showRowNumbers !== false,
                    readonlyColumns: options.readonlyColumns || [],
                    ...options
                };
                
                this.data = [];
                this.cells = new Map();
                this.state = {
                    selectingCell: false,
                    selectingForCell: null,
                    fillHandleActive: false,
                    fillStartCell: null,
                    fillHandleStarted: false
                };
                
                this.callbacks = {
                    onChange: null,
                    onValidate: null
                };
                
                this.recalcTimer = null;
                
                this.init();
            }
            
            init() {
                this.container.innerHTML = `
                    <div class="excel-grid-wrapper">
                        <table class="excel-table">
                            <thead id="${this.container.id}-thead"></thead>
                            <tbody id="${this.container.id}-tbody"></tbody>
                        </table>
                    </div>
                `;
                
                this.thead = document.getElementById(`${this.container.id}-thead`);
                this.tbody = document.getElementById(`${this.container.id}-tbody`);
                
                this.renderHeaders();
            }
            
            renderHeaders() {
                let headersHTML = '<tr>';
                
                if (this.options.showRowNumbers) {
                    headersHTML += '<th class="row-number-header">#</th>';
                }
                
                this.options.headers.forEach(header => {
                    headersHTML += `<th>${header}</th>`;
                });
                
                headersHTML += '</tr>';
                this.thead.innerHTML = headersHTML;
            }
            
            loadData(rows) {
                this.data = rows;
                this.tbody.innerHTML = '';
                this.cells.clear();
                
                rows.forEach((row, rowIndex) => {
                    this.addRow(row, rowIndex);
                });
            }
            
            addRow(rowData, rowIndex) {
                const tr = document.createElement('tr');
                let cellHTML = '';
                
                if (this.options.showRowNumbers) {
                    cellHTML += `<td class="row-number">${rowIndex + 1}</td>`;
                }
                
                rowData.forEach((cellData, colIndex) => {
                    const isReadonly = this.isColumnReadonly(colIndex) || cellData.readonly;
                    const value = cellData.value !== undefined ? cellData.value : cellData;
                    const cellId = `${rowIndex}-${colIndex}`;
                    const textAlign = cellData.textAlign || (colIndex === 0 ? 'left' : 'right');
                    const dataKey = cellData.key || '';
                    
                    cellHTML += `
                        <td>
                            <div class="cell-wrapper">
                                <input 
                                    type="text" 
                                    class="excel-cell ${isReadonly ? 'readonly' : ''} ${textAlign === 'left' ? 'text-left' : ''}" 
                                    id="cell-${cellId}" 
                                    value="${value}"
                                    ${isReadonly ? 'readonly' : ''}
                                    ${dataKey ? `data-key="${dataKey}"` : ''}
                                    data-row="${rowIndex}"
                                    data-col="${colIndex}"
                                />
                                ${!isReadonly && this.options.allowFillHandle ? '<div class="fill-handle"></div>' : ''}
                            </div>
                        </td>
                    `;
                });
                
                tr.innerHTML = cellHTML;
                this.tbody.appendChild(tr);
                
                // Attach event listeners
                rowData.forEach((cellData, colIndex) => {
                    const cellId = `${rowIndex}-${colIndex}`;
                    const cell = document.getElementById(`cell-${cellId}`);
                    
                    if (cell && !cell.classList.contains('readonly')) {
                        this.attachCellListeners(cell, rowIndex, colIndex);
                        this.cells.set(cellId, cell);
                    }
                });
            }
            
            isColumnReadonly(colIndex) {
                return this.options.readonlyColumns.includes(colIndex);
            }
            
            attachCellListeners(cell, row, col) {
                // Input event
                cell.addEventListener('input', () => {
                    this.handleCellInput(cell, row, col);
                });
                
                // Focus event
                cell.addEventListener('focus', () => {
                    if (cell.dataset.formula) {
                        cell.value = cell.dataset.formula;
                    }
                });
                
                // Blur event
                cell.addEventListener('blur', () => {
                    if (cell.dataset.formula && cell.dataset.result) {
                        const result = parseFloat(cell.dataset.result);
                        if (!isNaN(result) && isFinite(result)) {
                            cell.value = this.formatNumber(result);
                        }
                    }
                });
                
                // Keyboard navigation
                cell.addEventListener('keydown', (e) => {
                    this.handleKeyboard(e, cell, row, col);
                });
                
                // Fill handle
                const fillHandle = cell.parentElement.querySelector('.fill-handle');
                if (fillHandle) {
                    this.attachFillHandleListeners(fillHandle, cell, row, col);
                }
            }
            
            handleCellInput(cell, row, col) {
                const value = cell.value;
                
                if (value.startsWith('=')) {
                    this.handleFormula(cell, row, col);
                } else {
                    delete cell.dataset.formula;
                    delete cell.dataset.result;
                }
                
                if (this.callbacks.onChange) {
                    this.callbacks.onChange(row, col, value);
                }
                
                // Trigger recalculation
                this.scheduleRecalc();
            }
            
            handleFormula(cell, row, col) {
                const formula = cell.value;
                cell.dataset.formula = formula;
                
                try {
                    const result = this.evaluateFormula(formula, row, col);
                    cell.dataset.result = result;
                    
                    // Show result when not focused
                    if (document.activeElement !== cell) {
                        cell.value = this.formatNumber(result);
                    }
                } catch (error) {
                    console.error('Formula error:', error);
                    cell.dataset.result = '0';
                }
            }
            
            evaluateFormula(formula, currentRow, currentCol) {
                let expression = formula.substring(1).trim();
                
                // Replace cell references
                const cellRefRegex = /\$?([A-Z]+)\$?(\d+)/g;
                expression = expression.replace(cellRefRegex, (match, col, row) => {
                    const value = this.getCellValue(row - 1, this.colToIndex(col));
                    return value;
                });
                
                // Handle functions
                expression = this.handleFunctions(expression);
                
                // Evaluate
                try {
                    const result = new Function(`return ${expression}`)();
                    return result;
                } catch (error) {
                    console.error('Eval error:', error);
                    return 0;
                }
            }
            
            handleFunctions(expression) {
                // SUM
                expression = expression.replace(/SUM\(([^)]+)\)/gi, (match, range) => {
                    const values = this.getRangeValues(range);
                    return values.reduce((sum, val) => sum + val, 0);
                });
                
                // AVERAGE
                expression = expression.replace(/AVERAGE\(([^)]+)\)/gi, (match, range) => {
                    const values = this.getRangeValues(range);
                    return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;
                });
                
                // MIN
                expression = expression.replace(/MIN\(([^)]+)\)/gi, (match, range) => {
                    const values = this.getRangeValues(range);
                    return values.length > 0 ? Math.min(...values) : 0;
                });
                
                // MAX
                expression = expression.replace(/MAX\(([^)]+)\)/gi, (match, range) => {
                    const values = this.getRangeValues(range);
                    return values.length > 0 ? Math.max(...values) : 0;
                });
                
                // ABS
                expression = expression.replace(/ABS\(([^)]+)\)/gi, (match, value) => {
                    return `Math.abs(${value})`;
                });
                
                return expression;
            }
            
            getRangeValues(range) {
                const values = [];
                
                if (range.includes(':')) {
                    const [start, end] = range.split(':');
                    const startMatch = start.match(/([A-Z]+)(\d+)/);
                    const endMatch = end.match(/([A-Z]+)(\d+)/);
                    
                    if (startMatch && endMatch) {
                        const startCol = this.colToIndex(startMatch[1]);
                        const startRow = parseInt(startMatch[2]) - 1;
                        const endCol = this.colToIndex(endMatch[1]);
                        const endRow = parseInt(endMatch[2]) - 1;
                        
                        for (let r = startRow; r <= endRow; r++) {
                            for (let c = startCol; c <= endCol; c++) {
                                values.push(this.getCellValue(r, c));
                            }
                        }
                    }
                } else {
                    values.push(parseFloat(range) || 0);
                }
                
                return values;
            }
            
            getCellValue(row, col) {
                const cellId = `${row}-${col}`;
                const cell = this.cells.get(cellId);
                
                if (!cell) return 0;
                
                if (cell.dataset.result) {
                    return parseFloat(cell.dataset.result) || 0;
                }
                
                const value = cell.value.replace(/\s/g, '').replace(/,/g, '');
                return parseFloat(value) || 0;
            }
            
            colToIndex(col) {
                let index = 0;
                for (let i = 0; i < col.length; i++) {
                    index = index * 26 + (col.charCodeAt(i) - 64);
                }
                return index - 1;
            }
            
            indexToCol(index) {
                let col = '';
                index += 1;
                while (index > 0) {
                    const mod = (index - 1) % 26;
                    col = String.fromCharCode(65 + mod) + col;
                    index = Math.floor((index - mod) / 26);
                }
                return col;
            }
            
            handleKeyboard(e, cell, row, col) {
                const key = e.key;
                let targetCell = null;
                
                if (key === 'ArrowUp') {
                    e.preventDefault();
                    targetCell = this.cells.get(`${row - 1}-${col}`);
                } else if (key === 'ArrowDown') {
                    e.preventDefault();
                    targetCell = this.cells.get(`${row + 1}-${col}`);
                } else if (key === 'ArrowLeft') {
                    e.preventDefault();
                    targetCell = this.cells.get(`${row}-${col - 1}`);
                } else if (key === 'ArrowRight') {
                    e.preventDefault();
                    targetCell = this.cells.get(`${row}-${col + 1}`);
                } else if (key === 'Enter') {
                    e.preventDefault();
                    targetCell = this.cells.get(`${row + 1}-${col}`);
                } else if (key === 'Tab') {
                    e.preventDefault();
                    targetCell = this.cells.get(`${row}-${col + 1}`);
                }
                
                if (targetCell) {
                    targetCell.focus();
                    targetCell.select();
                }
            }
            
            attachFillHandleListeners(fillHandle, cell, row, col) {
                fillHandle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.startFillHandle(cell, row, col);
                });
            }
            
            startFillHandle(cell, row, col) {
                this.state.fillHandleActive = true;
                this.state.fillStartCell = { cell, row, col };
                
                const handleMove = (e) => {
                    if (!this.state.fillHandleActive) return;
                    
                    const target = document.elementFromPoint(e.clientX, e.clientY);
                    if (target && target.classList.contains('excel-cell')) {
                        const targetRow = parseInt(target.dataset.row);
                        const targetCol = parseInt(target.dataset.col);
                        this.highlightFillRange(row, col, targetRow, targetCol);
                    }
                };
                
                const handleUp = () => {
                    if (this.state.fillHandleActive) {
                        this.completeFill();
                    }
                    document.removeEventListener('mousemove', handleMove);
                    document.removeEventListener('mouseup', handleUp);
                };
                
                document.addEventListener('mousemove', handleMove);
                document.addEventListener('mouseup', handleUp);
            }
            
            highlightFillRange(startRow, startCol, endRow, endCol) {
                this.cells.forEach((cell, id) => {
                    cell.classList.remove('filling');
                });
                
                const minRow = Math.min(startRow, endRow);
                const maxRow = Math.max(startRow, endRow);
                const minCol = Math.min(startCol, endCol);
                const maxCol = Math.max(startCol, endCol);
                
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        const cell = this.cells.get(`${r}-${c}`);
                        if (cell) {
                            cell.classList.add('filling');
                        }
                    }
                }
            }
            
            completeFill() {
                const fillingCells = Array.from(this.cells.values()).filter(c => c.classList.contains('filling'));
                
                if (fillingCells.length > 1 && this.state.fillStartCell) {
                    const sourceCell = this.state.fillStartCell.cell;
                    const sourceFormula = sourceCell.dataset.formula;
                    const sourceValue = sourceCell.value;
                    
                    fillingCells.forEach(targetCell => {
                        if (targetCell !== sourceCell && !targetCell.classList.contains('readonly')) {
                            if (sourceFormula) {
                                // Copy and adjust formula
                                const adjustedFormula = this.adjustFormula(
                                    sourceFormula,
                                    this.state.fillStartCell.row,
                                    this.state.fillStartCell.col,
                                    parseInt(targetCell.dataset.row),
                                    parseInt(targetCell.dataset.col)
                                );
                                targetCell.value = adjustedFormula;
                                this.handleFormula(targetCell, parseInt(targetCell.dataset.row), parseInt(targetCell.dataset.col));
                            } else {
                                targetCell.value = sourceValue;
                            }
                        }
                        targetCell.classList.remove('filling');
                    });
                    
                    this.scheduleRecalc();
                }
                
                this.state.fillHandleActive = false;
                this.state.fillStartCell = null;
            }
            
            adjustFormula(formula, fromRow, fromCol, toRow, toCol) {
                const rowDiff = toRow - fromRow;
                const colDiff = toCol - fromCol;
                
                return formula.replace(/(\$?)([A-Z]+)(\$?)(\d+)/g, (match, colLock, col, rowLock, row) => {
                    let newCol = col;
                    let newRow = parseInt(row);
                    
                    if (!colLock) {
                        const colIndex = this.colToIndex(col);
                        newCol = this.indexToCol(colIndex + colDiff);
                    }
                    
                    if (!rowLock) {
                        newRow = parseInt(row) + rowDiff;
                    }
                    
                    return `${colLock}${newCol}${rowLock}${newRow}`;
                });
            }
            
            scheduleRecalc() {
                if (this.recalcTimer) {
                    clearTimeout(this.recalcTimer);
                }
                
                this.recalcTimer = setTimeout(() => {
                    this.recalculateAll();
                }, 100);
            }
            
            recalculateAll() {
                this.cells.forEach((cell, id) => {
                    if (cell.dataset.formula) {
                        const [row, col] = id.split('-').map(Number);
                        this.handleFormula(cell, row, col);
                    }
                });
            }
            
            formatNumber(num) {
                if (isNaN(num) || !isFinite(num)) return '0';
                return num.toLocaleString('nb-NO', {
                    minimumFractionDigits: 0,
                    maximumFractionDigits: 2
                });
            }
            
            onCellChange(callback) {
                this.callbacks.onChange = callback;
            }
            
            getCellByKey(key) {
                for (const [id, cell] of this.cells.entries()) {
                    if (cell.dataset.key === key) {
                        return cell;
                    }
                }
                return null;
            }
            
            getAllCellsWithKeys() {
                const result = [];
                this.cells.forEach((cell, id) => {
                    if (cell.dataset.key) {
                        result.push(cell);
                    }
                });
                return result;
            }
        }
    </script>

    <!-- Main Game Script -->
    <script>
        // Task Definitions - Original 10 oppgaver
        // Task Definitions - Original 10 oppgaver
        const tasks = [
            {
                id: 1,
                title: "üïµÔ∏è Case 1: Manipulasjonsdetektiv - TechCorp AS",
                shortTitle: "Oppgave 1",
                description: `
                    <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid var(--error); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <strong>‚ö†Ô∏è MASTER LEVEL:</strong> Krever dyp analyse og kritisk tenkning
                    </div>
                    <h4>Situasjon:</h4>
                    <p>Du er revisor for TechCorp AS. Ved gjennomgang oppdager du:</p>
                    <ul>
                        <li>Kundefordringer: ‚Üë70% mens salg kun ‚Üë5%</li>
                        <li>Varelager: ‚Üë45% uten omsetnings√∏kning</li>
                        <li>Tre revisorskift p√• fem √•r</li>
                        <li>Totalkapital: ‚Üë40% uten forklaring</li>
                        <li>Avskrivninger: Redusert fra 20% til 10%</li>
                    </ul>
                `,
                solution: { rodeFlags: 5, korrigertResultat: 3200000, alvorlighetsgrad: 8 },
                hint: "R√∏de flagg: Fordringer vs salg, varelager, revisorskift, totalkapital, avskrivningspolitikk. Korrigert resultat m√• justeres.",
                explanation: "5 r√∏de flagg identifisert. Manipulering gjennom: fordringer‚Üë, varelager‚Üë, revisorskift, uklar kapital√∏kning, endret avskrivning."
            },
            {
                id: 2,
                title: "üö® Case 2: Krise - RetailMax AS",
                shortTitle: "Oppgave 2",
                description: `
                    <div style="background: rgba(239, 68, 68, 0.1); border: 2px solid var(--error); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <strong>‚ö†Ô∏è AKUTT:</strong> Selskapet er p√• konkursens rand!
                    </div>
                    <h4>Situasjon:</h4>
                    <ul>
                        <li>Likviditetsgrad 1: 0,4 (kritisk!)</li>
                        <li>Arbeidskapital: -3 000 000 kr</li>
                        <li>Brudd p√• l√•nebetingelser</li>
                        <li>8M forfaller om 2 uker</li>
                    </ul>
                `,
                solution: { nodvendigKapital: 8000000, nyLikviditetsgrad: 1.24, prioritet: 2 },
                hint: "8M forfaller. Faktoring + salg AM ‚âà 8,6M. LG1 = (Oml√∏psmidler + Tiltak) / Kortsiktig gjeld",
                explanation: "Kombinasjon av faktoring og anleggsmiddel-salg gir 8,6M likviditet raskt."
            },
            {
                id: 3,
                title: "ü§ù Case 3: Fusjon - Alpha kj√∏per Beta AS",
                shortTitle: "Oppgave 3",
                description: `
                    <h4>Beta AS data:</h4>
                    <ul>
                        <li>EK bokf√∏rt: 10 000 000 kr</li>
                        <li>√Örsresultat (snitt 3 √•r): 2 000 000 kr</li>
                        <li>Bransje-multiplikator: 6x EBIT</li>
                        <li>Skjulte reserver: 3 000 000 kr</li>
                    </ul>
                    <p><strong>Kj√∏pesum: 13M</strong></p>
                `,
                solution: { verdiMultiplikator: 12000000, korrigertEK: 13000000, goodwill: 0 },
                hint: "Verdi = √Örsresultat √ó 6. Korrigert EK = Bokf√∏rt + Skjulte. Goodwill = Kj√∏pesum - Korrigert EK",
                explanation: "Verdi: 2M√ó6=12M. Korrigert EK: 10M+3M=13M. Goodwill: 13M-13M=0"
            },
            {
                id: 4,
                title: "üßæ Case 4: Kompleks MVA - ImportExport AS",
                shortTitle: "Oppgave 4",
                description: `
                    <h4>Transaksjoner denne m√•neden:</h4>
                    <ul>
                        <li>Import EU: 100k + import-MVA 25k (omvendt)</li>
                        <li>Eksport Norge: 200k (0% MVA)</li>
                        <li>Innenlands salg: 150k + MVA 37,5k</li>
                        <li>Representasjon (50% ikke fradrag): 10k + MVA 2,5k</li>
                        <li>Firmabil (20% privat): 40k + MVA 10k</li>
                    </ul>
                `,
                solution: { utgaendeMVA: 62500, inngaendeMVA: 34750, mvaTilBetaling: 27750 },
                hint: "Utg√•ende = Import(omvendt) + Innenlands. Inng√•ende = Import + (Rep√ó50%) + (Bil√ó80%). Oppgj√∏r = Utg√•ende - Inng√•ende",
                explanation: "Utg√•ende: 25k+37,5k=62,5k. Inng√•ende: 25k+1,25k+8k=34,25k. Oppgj√∏r: 28,25k"
            },
            {
                id: 5,
                title: "üí∞ Case 5: Skatt-puslespill - MegaCorp AS",
                shortTitle: "Oppgave 5",
                description: `
                    <h4>Data:</h4>
                    <ul>
                        <li>Regnskap resultat f√∏r skatt: 10 000 000 kr</li>
                        <li>Representasjon (ikke fradrag): 500 000 kr</li>
                        <li>B√∏ter: 200 000 kr</li>
                        <li>Avskr. diff. (regnskap - skatt): 500 000 kr</li>
                        <li>Fremf√∏rbart underskudd: 2 000 000 kr</li>
                        <li>Skattesats: 22%</li>
                    </ul>
                `,
                solution: { skattemessigResultat: 8200000, betalbarSkatt: 1804000, skattekostnad: 1694000 },
                hint: "Skatt.res = Regn.res + Permanente + Midlertidige - Fremf√∏rbart. Betalbar = Skatt.res √ó 22%. Utsatt skatt = Midlertidig √ó 22%",
                explanation: "8,2M √ó 22% = 1,804M betalbar. Endring utsatt: -500k√ó22%=-110k. Total: 1,694M"
            },
            {
                id: 6,
                title: "‚öñÔ∏è Case 6: Regnskapspolitikk-dilemma",
                shortTitle: "Oppgave 6",
                description: `
                    <h4>Ledelsen foresl√•r:</h4>
                    <ul>
                        <li>Aktivere FoU: +2M</li>
                        <li>√òke avskrivningstid 5‚Üí10 √•r: +500k</li>
                        <li>Redusere tap-avsetning 5%‚Üí1%: +400k</li>
                        <li>Endre inntektsf√∏ring: +1M</li>
                    </ul>
                `,
                solution: { akseptableTiltak: 1, totalEffekt: 3900000, risiko: 8 },
                hint: "Kun tiltak 2 kan v√¶re akseptabelt hvis √∏konomisk levetid er reell. Andre = manipulering.",
                explanation: "Kun avskrivningstid kan forsvares. Andre tiltak = resultatstyring. H√∏y risiko."
            },
            {
                id: 7,
                title: "üí∏ Case 7: Gjeldsforhandling - DebtCo AS",
                shortTitle: "Oppgave 7",
                description: `
                    <h4>Situasjon (EK: -16M!):</h4>
                    <ul>
                        <li>Bygninger (marked): 18M (bok: 20M)</li>
                        <li>Varelager (marked): 3M (bok: 5M)</li>
                        <li>Fordringer (90% innkrevd): 8M</li>
                        <li>Bank: 1M</li>
                        <li>Total gjeld: 50M</li>
                        <li>Prioritert (l√∏nn+skatt+sikret): 25M</li>
                    </ul>
                `,
                solution: { reellVerdi: 30200000, dekningsgradUsikret: 20, forslag: 0.20 },
                hint: "Reell = Markedsverdier. Etter prioritert, hva gjenst√•r? Dekningsgrad = Rest / Usikret gjeld",
                explanation: "30,2M - 25M prioritert = 5,2M. Usikret 25M ‚Üí dekningsgrad 20,8% ‚âà 20%"
            },
            {
                id: 8,
                title: "üè¢ Case 8: Konsernregnskap Light",
                shortTitle: "Oppgave 8",
                description: `
                    <h4>Parent AS eier 80% av Child AS:</h4>
                    <ul>
                        <li>Salg Parent‚ÜíChild: 5M (elimineres)</li>
                        <li>L√•n Parent‚ÜíChild: 2M (elimineres)</li>
                        <li>Rente internt: 100k (elimineres)</li>
                        <li>Parent resultat: 8M</li>
                        <li>Child resultat: 2M</li>
                    </ul>
                `,
                solution: { konsolidertResultat: 9900000, minoritet: 400000, majoritet: 9500000 },
                hint: "Konsol = Sum - Rente. Minoritet = 20% av Child. Majoritet = Rest",
                explanation: "9,9M konsolidert. Minoritet 400k. Majoritet 9,5M"
            },
            {
                id: 9,
                title: "üìâ Case 9: Budsjettavvik - PlanCorp AS",
                shortTitle: "Oppgave 9",
                description: `
                    <h4>Budsjett 2024 vs Faktisk:</h4>
                    <ul>
                        <li>Omsetning: 100M ‚Üí 85M</li>
                        <li>Resultat: 10M ‚Üí -2M</li>
                    </ul>
                `,
                solution: { avvikOmsetning: -15000000, avvikResultat: -12000000, budsjettkvalitet: 3 },
                hint: "Avvik = Faktisk - Budsjett. Negativt = d√•rligere. Budsjett var urealistisk.",
                explanation: "Avvik: -15M omsetning, -12M resultat. Budsjettkvalitet 3/10 (urealistisk)"
            },
            {
                id: 10,
                title: "üì¶ Case 10: Kompleks Varekostnad",
                shortTitle: "Oppgave 10",
                description: `
                    <h4>Innkj√∏p (kronologisk):</h4>
                    <ul>
                        <li>100 stk √† 1000 kr = 100k</li>
                        <li>150 stk √† 1200 kr = 180k</li>
                        <li>200 stk √† 1100 kr = 220k</li>
                        <li>Produsert: 400 stk, Solgt: 350 stk</li>
                    </ul>
                `,
                solution: { varekostnadFIFO: 385000, gjennomsnittspris: 1111, varekostnadGjennomsnitt: 388889 },
                hint: "FIFO: F√∏rst inn f√∏rst ut. Gjennomsnitt = Total / Antall. Kostnad = Solgt √ó Pris",
                explanation: "FIFO: 100√ó1000+150√ó1200+100√ó1100=385k. Snitt: 500k/450=1111. Kostnad: 388,9k"
            }
        ];
        let gameState = {
            currentTask: 0,
            completedTasks: [],
            score: 0,
            unlocked: false,
            theme: 'dark'
        };

        let currentGrid = null;

        // Initialize
        function init() {
            checkUnlockStatus();
            loadProgress();
            loadTaskList();
            loadTask(0);
            
            // Vis Pro badge hvis bruker er Pro
            const userProfile = JSON.parse(localStorage.getItem('userProfile') || '{}');
            if (userProfile.subscription === 'pro') {
                document.getElementById('pro-badge').style.display = 'block';
            }
        }

        // Check if module should be unlocked
        function checkUnlockStatus() {
            // üåü PRO BYPASS: Pro brukere f√•r full tilgang
            const userProfile = JSON.parse(localStorage.getItem('userProfile') || '{}');
            const isPro = userProfile.subscription === 'pro';
            
            if (isPro) {
                gameState.unlocked = true;
                document.getElementById('lock-screen').style.display = 'none';
                return; // Skip requirements check
            }

            // For gratis brukere: Sjekk krav
            const quizProgress = JSON.parse(localStorage.getItem('quiz_progress') || '{}');
            const bokforingProgress = JSON.parse(localStorage.getItem('bokforing_progress') || '{}');
            const analyseProgress = JSON.parse(localStorage.getItem('analyse_progress') || '{}');
            const caseProgress = JSON.parse(localStorage.getItem('case_progress') || '{}');

            const quizPercent = ((quizProgress.completedQuestions || 0) / 20) * 100;
            const bokforingPercent = ((bokforingProgress.completedTasks || 0) / 15) * 100;
            const analysePercent = ((analyseProgress.completedTasks || 0) / 8) * 100;
            const casePercent = ((caseProgress.completedTasks || 0) / 5) * 100;

            const overallPercent = (quizPercent + bokforingPercent + analysePercent + casePercent) / 4;

            document.getElementById('req-quiz').textContent = Math.round(quizPercent) + '%';
            document.getElementById('req-quiz').className = quizPercent >= 80 ? 'requirement-met' : 'requirement-not-met';
            
            document.getElementById('req-bokforing').textContent = Math.round(bokforingPercent) + '%';
            document.getElementById('req-bokforing').className = bokforingPercent >= 80 ? 'requirement-met' : 'requirement-not-met';
            
            document.getElementById('req-analyse').textContent = Math.round(analysePercent) + '%';
            document.getElementById('req-analyse').className = analysePercent >= 80 ? 'requirement-met' : 'requirement-not-met';
            
            document.getElementById('req-case').textContent = Math.round(casePercent) + '%';
            document.getElementById('req-case').className = casePercent >= 80 ? 'requirement-met' : 'requirement-not-met';

            const progressFill = document.getElementById('overall-progress');
            progressFill.style.width = overallPercent + '%';
            progressFill.textContent = Math.round(overallPercent) + '%';

            if (overallPercent >= 80 || gameState.unlocked) {
                gameState.unlocked = true;
                document.getElementById('lock-screen').style.display = 'none';
            }
        }

        function loadTaskList() {
            const taskList = document.getElementById('task-list');
            taskList.innerHTML = '';

            tasks.forEach((task, index) => {
                const isCompleted = gameState.completedTasks.includes(task.id);
                const isActive = index === gameState.currentTask;

                const item = document.createElement('div');
                item.className = 'task-item' + (isActive ? ' active' : '') + (isCompleted ? ' completed' : '');
                item.onclick = () => loadTask(index);

                item.innerHTML = `
                    <div class="task-item-title">${task.shortTitle}</div>
                    <div class="task-item-desc">${task.title}</div>
                    <span class="difficulty-badge difficulty-master">‚ö° EKSTREMT</span>
                    ${isCompleted ? '<span class="status-badge completed">‚úì Fullf√∏rt</span>' : '<span class="status-badge not-started">Ikke startet</span>'}
                `;

                taskList.appendChild(item);
            });
        }

        function loadTask(index) {
            gameState.currentTask = index;
            const task = tasks[index];

            // Update header
            document.getElementById('task-title').textContent = task.title;
            document.getElementById('task-description').innerHTML = task.description;

            // Create simple grid without ExcelGrid component
            const gridHTML = `
                <div style="background: var(--bg-secondary); border: 2px solid var(--border-color); border-radius: 10px; padding: 20px; margin: 20px 0;">
                    <table class="spreadsheet">
                        <thead>
                            <tr>
                                <th style="width: 50px">#</th>
                                <th>Sp√∏rsm√•l</th>
                                <th style="width: 200px">Svar</th>
                            </tr>
                        </thead>
                        <tbody id="task-tbody"></tbody>
                    </table>
                </div>
            `;
            
            document.getElementById('excel-grid-container').innerHTML = gridHTML;
            
            // Add rows for each solution key
            const tbody = document.getElementById('task-tbody');
            Object.keys(task.solution).forEach((key, i) => {
                const label = key.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase()).trim();
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="background: var(--bg-tertiary); color: var(--text-secondary); text-align: center; font-weight: bold; padding: 10px;">${i + 1}</td>
                    <td style="padding: 0;"><input type="text" class="excel-cell readonly text-left" value="${label}" readonly style="background: var(--bg-tertiary); color: var(--text-secondary);"></td>
                    <td style="padding: 0;"><input type="text" class="excel-cell" data-key="${key}" placeholder="Skriv svar"></td>
                `;
                tbody.appendChild(row);
            });

            // Hide feedback and hint
            document.getElementById('feedback').className = 'feedback';
            document.getElementById('hint-box').classList.remove('show');

            // Focus first input
            setTimeout(() => {
                const firstInput = tbody.querySelector('.excel-cell:not(.readonly)');
                if (firstInput) firstInput.focus();
            }, 100);

            loadTaskList();
            saveProgress();
        }

        function checkAnswer() {
            const task = tasks[gameState.currentTask];
            const inputs = document.querySelectorAll('.excel-cell[data-key]');
            
            let correct = 0;
            let total = Object.keys(task.solution).length;

            inputs.forEach(input => {
                const key = input.dataset.key;
                const expected = task.solution[key];
                const value = parseFloat(input.value.replace(/\s/g, '').replace(/,/g, '')) || 0;

                const tolerance = Math.abs(expected) * 0.05;
                
                if (Math.abs(value - expected) <= tolerance || Math.abs(value - expected) <= 1) {
                    correct++;
                    input.parentElement.style.background = 'rgba(74, 222, 128, 0.2)';
                } else {
                    input.parentElement.style.background = 'rgba(239, 68, 68, 0.2)';
                }
            });

            const feedback = document.getElementById('feedback');
            if (correct === total) {
                gameState.score += 20;
                if (!gameState.completedTasks.includes(task.id)) {
                    gameState.completedTasks.push(task.id);
                }
                feedback.className = 'feedback correct show';
                feedback.innerHTML = `üéâ PERFEKT!<br><small>${task.explanation}</small>`;
            } else {
                feedback.className = 'feedback incorrect show';
                feedback.textContent = `‚úó ${correct}/${total} riktige`;
            }

            updateStats();
            loadTaskList();
            saveProgress();
        }

        function showHint() {
            const task = tasks[gameState.currentTask];
            document.getElementById('hint-content').innerHTML = task.hint;
            document.getElementById('hint-box').classList.add('show');
        }

        function resetTask() {
            loadTask(gameState.currentTask);
        }

        function updateStats() {
            document.getElementById('completed-count').textContent = gameState.completedTasks.length;
            document.getElementById('score').textContent = gameState.score;
        }

        function saveProgress() {
            localStorage.setItem('hjernetrim_progress', JSON.stringify(gameState));
        }

        function loadProgress() {
            const saved = localStorage.getItem('hjernetrim_progress');
            if (saved) {
                const p = JSON.parse(saved);
                gameState.completedTasks = p.completedTasks || [];
                gameState.score = p.score || 0;
                gameState.theme = p.theme || 'dark';
                gameState.unlocked = p.unlocked || false;
                document.body.setAttribute('data-theme', gameState.theme);
                updateStats();
            }
        }

        function toggleTheme() {
            gameState.theme = gameState.theme === 'dark' ? 'light' : 'dark';
            document.body.setAttribute('data-theme', gameState.theme);
            saveProgress();
        }

        function backToMenu() {
            saveProgress();
            window.location.href = 'index.html';
        }

        function forceUnlock() {
            gameState.unlocked = true;
            document.getElementById('lock-screen').style.display = 'none';
            saveProgress();
        }

        function openWiki() {
            window.open('wiki.html', '_blank');
        }

        // Calculator functions
        let calcState = {
            display: '0',
            lastWasEquals: false
        };

        function toggleCalculator() {
            const calc = document.getElementById('calculator');
            calc.classList.toggle('show');
        }

        function calcInput(value) {
            if (calcState.lastWasEquals) {
                calcState.display = value;
                calcState.lastWasEquals = false;
            } else {
                if (calcState.display === '0' && value !== '.') {
                    calcState.display = value;
                } else {
                    calcState.display += value;
                }
            }
            document.getElementById('calc-display').textContent = calcState.display;
        }

        function calcClear() {
            calcState.display = '0';
            calcState.lastWasEquals = false;
            document.getElementById('calc-display').textContent = '0';
        }

        function calcEquals() {
            try {
                // Replace √ó with *
                let expression = calcState.display.replace(/√ó/g, '*');
                const result = eval(expression);
                calcState.display = result.toString();
                calcState.lastWasEquals = true;
                document.getElementById('calc-display').textContent = result;
            } catch (error) {
                document.getElementById('calc-display').textContent = 'Error';
                calcState.display = '0';
            }
        }

        // Initialize on load
        window.onload = function() {
            // üåü FOR TESTING: Sett Pro-status (fjern i produksjon)
            const userProfile = JSON.parse(localStorage.getItem('userProfile') || '{}');
            if (!userProfile.subscription) {
                userProfile.subscription = 'pro'; // Default til Pro for testing
                userProfile.name = 'Truls (Pro)';
                localStorage.setItem('userProfile', JSON.stringify(userProfile));
                console.log('‚úÖ Pro-tilgang aktivert for testing');
            }
            
            init();
        };
    </script>
    
    <!-- Theme Manager -->
    <script src="js/theme-manager.js"></script>
    <script>
        // Initialize theme after DOM loads
        if (typeof ThemeManager !== 'undefined' && ThemeManager.init) {
            ThemeManager.init();
        }
    </script>
</body>
</html>
